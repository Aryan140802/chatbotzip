
import '../styles/GraphCarousel.css';
import {
  BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer
} from 'recharts';

import Download from '../assets/down-arrow.png';
import {
  getServiceWiseExp5,
  getServiceWiseSys5,
  getIpWiseExp5,
  getIpWiseSys5,
  getPortWiseExp5,
  getPortWiseSys5
} from "../api/PostApi";

import { useState, useEffect, useRef } from "react";

// Format large numbers
const formatHits = (value) => {
  if (value >= 10000000) return (value / 10000000).toFixed(2) + ' Cr';
  if (value >= 100000) return (value / 100000).toFixed(2) + ' L';
  if (value >= 1000) return (value / 1000).toFixed(2) + ' K';
  return value;
};

const ThreeDBar = (props) => {
  const { x, y, width, height, fill } = props;
  const depth = 6;

  return (
    <g>
      <rect
        x={x}
        y={y}
        width={width}
        height={height}
        fill={fill}
        style={{
          transition: "all 0.3s ease",
        }}
        className="custom-bar"
      />
      <polygon
        points={`${x},${y} ${x + depth},${y - depth} ${x + width + depth},${y - depth} ${x + width},${y}`}
        fill="#ffffff33"
      />
      <polygon
        points={`${x + width},${y} ${x + width + depth},${y - depth} ${x + width + depth},${y + height - depth} ${x + width},${y + height}`}
        fill="#00000033"
      />
    </g>
  );
};

const GraphCarousel = () => {
  const [currentIndex, setCurrentIndex] = useState(0);
  const [paused, setPaused] = useState(false);
  const [charts, setCharts] = useState([]);
  const [dropdownOpen, setDropdownOpen] = useState(false);
  const [calendarOpen, setCalendarOpen] = useState(false);
  const [selectedDate, setSelectedDate] = useState(null);
  const [isLoading, setIsLoading] = useState(true);

  const [selectedTimeLabel, setSelectedTimeLabel] = useState("5 min");
  const [selectedTimeValue, setSelectedTimeValue] = useState("5m");

  const calendarRef = useRef(null);

  const timeOptions = [
    { label: "5 min", value: "5m" },
    { label: "15 min", value: "15m" },
    { label: "30 min", value: "30m" },
    { label: "1 hour", value: "1h" },
    { label: "Till now", value: "now" },
    { label: "Yesterday", value: "yesterday" },
    { label: "Custom date", value: "custom" },
  ];

  // Base titles for different chart types
  const baseTitles = [
    'Service-wise Exp Data',
    'Service-wise Sys Data',
    'IP-wise Exp Data',
    'IP-wise Sys Data',
    'Port-wise Exp Data',
    'Port-wise Sys Data'
  ];

  const fetchFilteredData = async (timeRange = "5m") => {
    setIsLoading(true);
    try {
      const [
        serviceExp,
        serviceSys,
        ipExp,
        ipSys,
        portExp,
        portSys
      ] = await Promise.all([
        getServiceWiseExp5(timeRange),
        getServiceWiseSys5(timeRange),
        getIpWiseExp5(timeRange),
        getIpWiseSys5(timeRange),
        getPortWiseExp5(timeRange),
        getPortWiseSys5(timeRange)
      ]);

      const formatData = (data, key) =>
        data.map(item => ({
          ...item,
          [key]: item[key].toString().trim(),
          Hits: Number(item.Hits),
          logVal: Number(item.logVal)
        }));

      // For custom date, use the formatted date in the chart title
      const timeDisplay = timeRange?.startsWith('custom_') && selectedDate
        ? formatDate(selectedDate)
        : selectedTimeLabel;

      return [
        { data: formatData(serviceExp.data.service_wise_top5, 'Service_name'), dataKeyX: 'Service_name', baseTitle: baseTitles[0] },
        { data: formatData(serviceSys.data.service_wise_top5, 'Service_name'), dataKeyX: 'Service_name', baseTitle: baseTitles[1] },
        { data: formatData(ipExp.data.Ip_wise_top5, 'Ip'), dataKeyX: 'Ip', baseTitle: baseTitles[2] },
        { data: formatData(ipSys.data.Ip_wise_top5, 'Ip'), dataKeyX: 'Ip', baseTitle: baseTitles[3] },
        { data: formatData(portExp.data.port_wise_top5, 'Port'), dataKeyX: 'Port', baseTitle: baseTitles[4] },
        { data: formatData(portSys.data.port_wise_top5, 'Port'), dataKeyX: 'Port', baseTitle: baseTitles[5] }
      ].map(({ data, dataKeyX, baseTitle }) => ({
        baseTitle,
        title: `${baseTitle} of ${timeDisplay}`,
        rawData: data,
        chart: (
          <ResponsiveContainer>
            <BarChart data={data} margin={{ top: 30, right: 30, left: 30, bottom: 60 }} barCategoryGap={10}>
              <defs>
                <linearGradient id="barGradient" x1="0" y1="0" x2="0" y2="1">
                  <stop offset="0%" stopColor="#f285c1" />
                  <stop offset="100%" stopColor="#8e2b90" />
                </linearGradient>
              </defs>
              <CartesianGrid strokeDasharray="3 3" stroke="#ffffff33" />
              <XAxis
                dataKey={dataKeyX}
                stroke="#f7f7f7"
                interval={0}
                angle={-30}
                textAnchor="end"
                height={60}
                tick={{ fontSize: 10, fill: '#f7f7f7' }}
              />
              <YAxis
                tick={{ fill: '#f7f7f7' }}
                axisLine
                showLine
                tickFormatter={formatHits}
                domain={[0, (dataMax) => Math.ceil(dataMax * 1.1)]}
              />
              <Tooltip
                contentStyle={{ backgroundColor: '#2e1a3b', borderColor: '#f285c1', color: '#fff', borderRadius: '8px' }}
                itemStyle={{ color: '#fff' }}
                labelStyle={{ color: '#f285c1' }}
                formatter={(value, name, props) => {
                  if (name === 'Hits') {
                    const formattedHits = formatHits(props.payload.Hits);
                    return [`${formattedHits} (${props.payload.Hits})`, 'Hits'];
                  }
                  return value;
                }}
                labelFormatter={(label) => `${dataKeyX}: ${label}`}
              />
              <Bar dataKey="Hits" fill="url(#barGradient)" shape={ThreeDBar} barSize={50} />
            </BarChart>
          </ResponsiveContainer>
        )
      }));
    } finally {
      setIsLoading(false);
    }
  };

  // Function to update chart titles without refetching data
  const updateChartTitles = (timeDisplay) => {
    if (charts.length === 0) return;
     console.log("in charts");
    const updatedCharts = charts.map((chart, index) => ({
      ...chart,
      title: `${baseTitles[index]} of ${timeDisplay}`
    }));

    setCharts(updatedCharts);
  };

  useEffect(() => {
    fetchFilteredData(selectedTimeValue).then(setCharts);
  }, []);

  useEffect(() => {
    if (paused) return;
    const interval = setInterval(() => {
      setCurrentIndex((prevIndex) => (prevIndex === charts.length - 1 ? 0 : prevIndex + 1));
    }, 5000);
    return () => clearInterval(interval);
  }, [paused, charts.length]);



const handleTimeChange = async (option) => {
  if (option.value === "custom") {
    setDropdownOpen(false);
    setCalendarOpen(true);
    return;
  }

  setSelectedTimeLabel(option.label);
  setSelectedTimeValue(option.value);
  setDropdownOpen(false);
  setCalendarOpen(false);
  setPaused(true);

  // Fetch using the value directly, not from state
  try {
    console.log("updating")
    const updatedCharts = await fetchFilteredData(option.value);  // <- Use option.value here
    setCharts(updatedCharts);
    setCurrentIndex(0);
  } finally {
    setPaused(false);
  }
};




  const handleDateSelect = async (date) => {
    const formattedDate = formatDate(date);
    const dateValue = `custom_${date.toISOString().split('T')[0]}`;

    setSelectedDate(date);
    setSelectedTimeLabel(`Custom: ${formattedDate}`);
    setSelectedTimeValue(dateValue);
    setCalendarOpen(false);
    setPaused(true);

    // Update titles immediately
    updateChartTitles(`Custom: ${formattedDate}`);

    // Fetch and update data
    try {
      const updatedCharts = await fetchFilteredData(dateValue);
      setCharts(updatedCharts);
      setCurrentIndex(0);
    } finally {
      setPaused(false);
    }
  };

  const formatDate = (date) => {
    return date.toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      year: 'numeric'
    });
  };

  // Generate calendar days
  const generateCalendarDays = () => {
    const today = new Date();
    const days = [];
    const weekdays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

    // Add weekday headers
    weekdays.forEach(day => {
      days.push(<div key={`weekday-${day}`} className="calendar-weekday">{day}</div>);
    });

    // Calculate first day to display (start of month or 7 days ago, whichever is later)
    const sevenDaysAgo = new Date(today);
    sevenDaysAgo.setDate(today.getDate() - 6); // 7 days including today

    const firstDayOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
    const startDate = new Date(Math.max(sevenDaysAgo.getTime(), firstDayOfMonth.getTime()));

    // Fill in leading empty cells for the first week
    const firstDayOfWeek = startDate.getDay();
    for (let i = 0; i < firstDayOfWeek; i++) {
      days.push(<div key={`empty-start-${i}`} className="calendar-day"></div>);
    }

    // Fill in the days of the month
    const lastDayOfMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0).getDate();
    for (let day = startDate.getDate(); day <= lastDayOfMonth; day++) {
      const date = new Date(today.getFullYear(), today.getMonth(), day);
      const isDisabled = date > today || date < sevenDaysAgo;
      const isSelected = selectedDate && date.toDateString() === selectedDate.toDateString();

      days.push(
        <div
          key={`day-${day}`}
          className={`calendar-day ${isDisabled ? 'disabled' : ''} ${isSelected ? 'selected' : ''}`}
          onClick={() => !isDisabled && handleDateSelect(date)}
        >
          {day}
        </div>
      );
    }

    return days;
  };

  const downloadCSV = (data, filename = 'chart-data.csv') => {
    if (!data || !data.length) return;
    const keys = Object.keys(data[0]);
    const csvContent = [
      keys.join(','),
      ...data.map(row => keys.map(key => `"${row[key]}"`).join(','))
    ].join('\n');
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.setAttribute('download', filename);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  const goToSlide = (index) => setCurrentIndex(index);

  const toggleDropdown = () => {
    setDropdownOpen(!dropdownOpen);
    setCalendarOpen(false);
  };

  // Close dropdown and calendar when clicking outside
  useEffect(() => {
    if (!dropdownOpen && !calendarOpen) return;

    const handleClickOutside = (event) => {
      if (!event.target.closest('.dropdown') && !event.target.closest('.calendar-container')) {
        setDropdownOpen(false);
        setCalendarOpen(false);
      }
    };

    document.addEventListener('click', handleClickOutside);
    return () => document.removeEventListener('click', handleClickOutside);
  }, [dropdownOpen, calendarOpen]);

  if (!charts.length) return <div className="loading-container">Loading charts...</div>;

  return (
    <div className="carousel-container">
      <div className="carousel-header">
        <div className="timeline-selector">
          <div className="dropdown" onClick={(e) => e.stopPropagation()}>
            <button className="dropdown-toggle" onClick={toggleDropdown}>
              {selectedTimeLabel} ▼
            </button>
            <ul className={`dropdown-menu ${dropdownOpen ? 'show' : ''}`}>
              {timeOptions.map((option) => (
                <li
                  key={option.value}
                  onClick={() => handleTimeChange(option)}
                  className={option.value === selectedTimeValue ? 'selected' : ''}
                >
                  {option.label}
                </li>
              ))}
            </ul>

            {calendarOpen && (
              <div className="calendar-container" ref={calendarRef}>
                <div className="calendar-header">
                  {new Date().toLocaleDateString('en-US', { month: 'long', year: 'numeric' })}
                </div>
                <div className="calendar">
                  {generateCalendarDays()}
                </div>
              </div>
            )}
          </div>
        </div>
        <h2>{isLoading ? `Loading ${charts[currentIndex]?.baseTitle || ''}...` : charts[currentIndex]?.title}</h2>
        <div className="download-button-wrapper">
          <button
            className="download-button"
            onClick={() =>
              downloadCSV(charts[currentIndex].rawData, `${charts[currentIndex].title}.csv`)
            }
            disabled={isLoading}
          >
            <div className="logo-wrapper">
              <img className="logo" src={Download} alt="Download Icon" style={{ height: '36px', marginRight: '3px' }} />
            </div>
          </button>
        </div>
      </div>

      <div className="carousel-graph" onMouseEnter={() => setPaused(true)} onMouseLeave={() => setPaused(false)}>
        {isLoading ? (
          <div className="loading-overlay">Loading data...</div>
        ) : (
          charts.map((item, index) => (
            <div key={index} className={`chart-fade ${index === currentIndex ? 'active' : ''}`} style={{ display: index === currentIndex ? 'block' : 'none' }}>
              {item.chart}
            </div>
          ))
        )}
      </div>

      <div className="carousel-dots">
        {charts.map((_, index) => (
          <span
            key={index}
            className={`dot ${index === currentIndex ? 'active' : ''} ${paused ? 'paused' : ''}`}
            onClick={() => goToSlide(index)}
          />
        ))}
      </div>
    </div>
  );
};

export default GraphCarousel;
