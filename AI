#!/usr/bin/env python3

import subprocess
import json
import os
import socket
from datetime import datetime

# ================= CONFIG =================
ENVIRONMENT = "PR"              # PR or DR
SERVER_ID = "24"                # 24 / 25 / 40 / 42
ACE_REST_PORT = 4414

TRUSTSTORE_PATH = "/opt/IBM/Broker_Properties/JKS/EISBRK10_PROD_N1_TRUSTSTORE.jks"
KEYSTORE_PATH   = "/opt/IBM/Broker_Properties/JKS/EISBRK10_PROD_N1_KEYSTORE.jks"
ENDPOINT_PUBLIC = "/opt/IBM/EndPoint_Public"
STOREPASS       = "password"

OUTPUT_DIR = "/sync/outbox"
# ==========================================


def run(cmd):
    return subprocess.check_output(cmd, stderr=subprocess.DEVNULL, text=True)


# ---------- ACE DATA ----------
def get_ace_data():
    base = f"http://localhost:{ACE_REST_PORT}/apiv2"
    ace = {"integrationServers": {}}

    try:
        servers = json.loads(run(["curl", "-s", f"{base}/servers"]))["integrationServers"]
        for srv in servers:
            name = srv["name"]
            ace["integrationServers"][name] = {
                "executionGroups": {},
                "applications": []
            }

            egs = json.loads(run(["curl", "-s", f"{base}/servers/{name}/executiongroups"]))["executionGroups"]
            for eg in egs:
                ace["integrationServers"][name]["executionGroups"][eg["name"]] = {}

            apps = json.loads(run(["curl", "-s", f"{base}/servers/{name}/applications"]))["applications"]
            ace["integrationServers"][name]["applications"] = [a["name"] for a in apps]

    except Exception as e:
        ace["error"] = str(e)

    return ace


# ---------- MQ DATA ----------
def get_mq_data():
    mq = {"queueManagers": {}}

    try:
        qmlist = run(["dspmq"]).splitlines()
        qms = [l.split("(")[1].split(")")[0] for l in qmlist if "QMNAME" in l]

        for qm in qms:
            mq["queueManagers"][qm] = {
                "channels": [],
                "listeners": []
            }

            try:
                ch = run(["runmqsc", qm], input="DISPLAY CHANNEL(*)\nEND\n", text=True)
                mq["queueManagers"][qm]["channels"] = [
                    l.split("(")[1].split(")")[0]
                    for l in ch.splitlines() if "CHANNEL(" in l
                ]
            except:
                pass

            try:
                ls = run(["runmqsc", qm], input="DISPLAY LISTENER(*)\nEND\n", text=True)
                mq["queueManagers"][qm]["listeners"] = [
                    l.split("(")[1].split(")")[0]
                    for l in ls.splitlines() if "LISTENER(" in l
                ]
            except:
                pass

    except:
        pass

    return mq


# ---------- CERTIFICATES ----------
def parse_keytool(store_path):
    data = {}
    if not os.path.exists(store_path):
        return data

    out = run(["keytool", "-list", "-keystore", store_path, "-storepass", STOREPASS])
    aliases = [l.split(",")[0].strip() for l in out.splitlines() if "Entry" in l]

    for alias in aliases:
        det = run([
            "keytool", "-list", "-v",
            "-keystore", store_path,
            "-storepass", STOREPASS,
            "-alias", alias
        ])
        cert = {}
        for line in det.splitlines():
            if "Valid from:" in line:
                cert["valid_from"] = line.split(":", 1)[1].strip()
            elif "until:" in line:
                cert["valid_to"] = line.split("until:")[1].strip()
            elif "Owner:" in line:
                cert["owner"] = line.split(":", 1)[1].strip()
            elif "SHA1:" in line:
                cert["sha1"] = line.split("SHA1:")[1].strip()

        data[alias] = cert

    return data


def parse_endpoint():
    data = {}
    if not os.path.exists(ENDPOINT_PUBLIC):
        return data

    for f in os.listdir(ENDPOINT_PUBLIC):
        full = os.path.join(ENDPOINT_PUBLIC, f)
        try:
            out = run(["openssl", "x509", "-in", full, "-noout",
                       "-startdate", "-enddate", "-fingerprint"])
            cert = {}
            for l in out.splitlines():
                if l.startswith("notBefore="):
                    cert["valid_from"] = l.split("=", 1)[1]
                elif l.startswith("notAfter="):
                    cert["valid_to"] = l.split("=", 1)[1]
                elif "SHA1" in l:
                    cert["sha1"] = l.split("=", 1)[1]
            data[f] = cert
        except:
            pass

    return data


# ---------- MAIN ----------
def main():
    snapshot = {
        "environment": ENVIRONMENT,
        "server_id": SERVER_ID,
        "hostname": socket.gethostname(),
        "generated_at": datetime.utcnow().isoformat(),
        "ace": get_ace_data(),
        "mq": get_mq_data(),
        "certificates": {
            "truststore": parse_keytool(TRUSTSTORE_PATH),
            "keystore": parse_keytool(KEYSTORE_PATH),
            "endpoint_public": parse_endpoint()
        }
    }

    os.makedirs(OUTPUT_DIR, exist_ok=True)
    outfile = f"{OUTPUT_DIR}/server_snapshot_{ENVIRONMENT}_{SERVER_ID}.json"

    with open(outfile, "w") as f:
        json.dump(snapshot, f, indent=2)

    print(f"Generated: {outfile}")


if __name__ == "__main__":
    main()
