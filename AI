#!/usr/bin/env python3
import os
import json
import socket
import subprocess
import platform
import requests
from datetime import datetime
from requests.auth import HTTPBasicAuth
import urllib3

# Disable SSL warnings if using self-signed certificates
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# ================== CONFIG ==================
OUTPUT_DIR = "./sync"
ENDPOINT_PUBLIC_PATH = "/opt/IBM/EndPoint_Public"
TRUSTSTORE_PATH = "/opt/IBM/Broker_Properties/JKS/EISBRK10_PROD_N1_TRUSTSTORE.jks"
KEYSTORE_PATH = "/opt/IBM/Broker_Properties/JKS/EISBRK10_PROD_N1_KEYSTORE.jks"
JKS_PASSWORD = "password"

# ACE REST API Configuration
ACE_ADMIN_HOST = "eispraccexp-01"  # From your error message
ACE_ADMIN_PORT = 4414
ACE_USER = "v1019468"
ACE_PASS = "Eisking@1234567"
ACE_USE_HTTPS = False  # Set to True if using HTTPS
ACE_VERIFY_SSL = False  # Set to True to verify SSL certificates

# IBM MQ REST API Configuration (if available)
MQ_REST_HOST = "localhost"
MQ_REST_PORT = 9443
MQ_USE_REST = False  # Set to True if MQ REST API is available
# ============================================

def run(cmd):
    """Execute command and return output"""
    try:
        return subprocess.check_output(cmd, stderr=subprocess.STDOUT, text=True)
    except subprocess.CalledProcessError as e:
        return None

# ---------- SYSTEM INFO ----------
def get_system_info():
    uptime = run(["uptime"])
    return {
        "hostname": socket.gethostname(),
        "ip": socket.gethostbyname(socket.gethostname()),
        "os": platform.platform(),
        "uptime": uptime.strip() if uptime else "N/A",
    }

# ---------- CERTIFICATE READING ----------
def parse_openssl_cert(file_path):
    """Parse certificate using openssl (for .crt, .cer, .pem files)"""
    cmd = ["openssl", "x509", "-in", file_path, "-noout", "-startdate", "-enddate", "-fingerprint", "-subject"]
    output = run(cmd)
    
    if not output:
        return {"error": "Unable to read certificate"}
    
    data = {}
    for line in output.splitlines():
        if line.startswith("notBefore="):
            data["valid_from"] = line.split("=", 1)[1].strip()
        elif line.startswith("notAfter="):
            data["valid_to"] = line.split("=", 1)[1].strip()
        elif line.startswith("SHA1"):
            data["sha1"] = line.split("=", 1)[1].strip()
        elif line.startswith("subject="):
            data["subject"] = line.split("=", 1)[1].strip()
    
    return data

def parse_keytool_cert(store_path, storepass, alias):
    """Parse specific certificate from JKS using keytool"""
    cmd = ["keytool", "-list", "-v", "-keystore", store_path, "-storepass", storepass, "-alias", alias]
    output = run(cmd)
    
    if not output:
        return {"error": "Unable to read certificate"}
    
    data = {"alias": alias}
    for line in output.splitlines():
        if "Valid from:" in line:
            parts = line.split("until:")
            if len(parts) == 2:
                data["valid_from"] = parts[0].split("from:")[1].strip()
                data["valid_to"] = parts[1].strip()
        elif "SHA1:" in line:
            data["sha1"] = line.split("SHA1:")[1].strip()
        elif "Owner:" in line:
            data["owner"] = line.split("Owner:")[1].strip()
    
    return data

def list_jks_aliases(store_path, storepass):
    """List all aliases in a JKS keystore"""
    cmd = ["keytool", "-list", "-keystore", store_path, "-storepass", storepass]
    output = run(cmd)
    
    if not output:
        return []
    
    aliases = []
    for line in output.splitlines():
        if "keyEntry" in line or "trustedCertEntry" in line or "privateKeyEntry" in line:
            alias = line.split(",")[0].strip()
            aliases.append(alias)
    
    return aliases

def read_jks_store(store_path, store_name, storepass):
    """Read all certificates from a JKS store"""
    if not os.path.exists(store_path):
        return {store_name: {"error": "Store not found"}}
    
    aliases = list_jks_aliases(store_path, storepass)
    
    if not aliases:
        return {store_name: {"error": "Unable to read store or no certificates"}}
    
    certs = {}
    for alias in aliases:
        cert_data = parse_keytool_cert(store_path, storepass, alias)
        certs[alias] = cert_data
    
    return {store_name: certs}

def read_endpoint_certs():
    """Read all endpoint certificates from the endpoint public directory"""
    if not os.path.isdir(ENDPOINT_PUBLIC_PATH):
        return {"EndPoint_Public": {"error": "Directory not found"}}
    
    certs = {}
    files = os.listdir(ENDPOINT_PUBLIC_PATH)
    
    for file_name in files:
        full_path = os.path.join(ENDPOINT_PUBLIC_PATH, file_name)
        
        # Skip directories
        if not os.path.isfile(full_path):
            continue
        
        # Only process certificate files
        if file_name.endswith((".crt", ".cer", ".pem", ".cert")):
            cert_data = parse_openssl_cert(full_path)
            certs[file_name] = cert_data
    
    return {"EndPoint_Public": certs}

def read_all_certificates():
    """Collect all certificates from all sources"""
    all_certs = {}
    
    # Read Truststore
    truststore_certs = read_jks_store(TRUSTSTORE_PATH, "Truststore", JKS_PASSWORD)
    all_certs.update(truststore_certs)
    
    # Read Keystore
    keystore_certs = read_jks_store(KEYSTORE_PATH, "Keystore", JKS_PASSWORD)
    all_certs.update(keystore_certs)
    
    # Read EndPoint Public
    endpoint_certs = read_endpoint_certs()
    all_certs.update(endpoint_certs)
    
    return all_certs

# ---------- IBM ACE REST API ----------
def get_ace_info_rest():
    """Get ACE information using REST API"""
    protocol = "https" if ACE_USE_HTTPS else "http"
    base_url = f"{protocol}://{ACE_ADMIN_HOST}:{ACE_ADMIN_PORT}/apiv2"
    
    auth = HTTPBasicAuth(ACE_USER, ACE_PASS)
    
    info = {}
    
    try:
        # Get integration nodes
        nodes_url = f"{base_url}/servers"
        response = requests.get(nodes_url, auth=auth, verify=ACE_VERIFY_SSL, timeout=5)
        
        if response.status_code == 200:
            data = response.json()
            
            # Parse integration servers (execution groups)
            if "servers" in data:
                for server in data["servers"]:
                    server_name = server.get("name", "Unknown")
                    info[server_name] = {
                        "status": server.get("status", "Unknown"),
                        "type": server.get("type", "Unknown"),
                        "version": server.get("version", "Unknown"),
                    }
                    
                    # Get deployed applications for this server
                    apps_url = f"{base_url}/servers/{server_name}/applications"
                    try:
                        apps_response = requests.get(apps_url, auth=auth, verify=ACE_VERIFY_SSL, timeout=5)
                        if apps_response.status_code == 200:
                            apps_data = apps_response.json()
                            applications = []
                            if "applications" in apps_data:
                                for app in apps_data["applications"]:
                                    applications.append({
                                        "name": app.get("name", "Unknown"),
                                        "status": app.get("status", "Unknown")
                                    })
                            info[server_name]["applications"] = applications
                    except:
                        info[server_name]["applications"] = []
            
            return info if info else {"error": "No integration servers found"}
        
        elif response.status_code == 401:
            return {"error": "Authentication failed - check credentials"}
        else:
            return {"error": f"REST API returned status code {response.status_code}"}
    
    except requests.exceptions.ConnectionError:
        return {"error": f"Cannot connect to ACE REST API at {ACE_ADMIN_HOST}:{ACE_ADMIN_PORT}"}
    except requests.exceptions.Timeout:
        return {"error": "ACE REST API request timed out"}
    except Exception as e:
        return {"error": f"REST API error: {str(e)}"}

def get_ace_node_info_rest():
    """Get ACE integration node information (alternative endpoint)"""
    protocol = "https" if ACE_USE_HTTPS else "http"
    base_url = f"{protocol}://{ACE_ADMIN_HOST}:{ACE_ADMIN_PORT}/apiv2"
    
    auth = HTTPBasicAuth(ACE_USER, ACE_PASS)
    
    try:
        # Try to get node-level information
        node_url = f"{base_url}/"
        response = requests.get(node_url, auth=auth, verify=ACE_VERIFY_SSL, timeout=5)
        
        if response.status_code == 200:
            data = response.json()
            return {
                "node_name": data.get("name", "Unknown"),
                "version": data.get("version", "Unknown"),
                "architecture": data.get("architecture", "Unknown"),
                "operating_system": data.get("operatingSystem", "Unknown")
            }
        else:
            return {}
    except:
        return {}

# ---------- IBM MQ (keep simple dspmq for now) ----------
def get_mq_info():
    """Get IBM MQ queue manager information"""
    if MQ_USE_REST:
        return get_mq_info_rest()
    else:
        return get_mq_info_dspmq()

def get_mq_info_dspmq():
    """Get MQ info using dspmq command"""
    info = {}
    
    qms_output = run(["dspmq"])
    
    if not qms_output:
        return {"error": "MQ not accessible - dspmq failed"}
    
    for line in qms_output.splitlines():
        if "QMNAME" in line or "(" in line:
            try:
                name_part = line.split("(")[1].split(")")[0]
                status_part = line.split("STATUS(")[1].split(")")[0] if "STATUS(" in line else "Unknown"
                info[name_part] = {"status": status_part}
            except:
                continue
    
    return info if info else {"error": "No queue managers found"}

def get_mq_info_rest():
    """Get MQ info using REST API (if available)"""
    protocol = "https"
    base_url = f"{protocol}://{MQ_REST_HOST}:{MQ_REST_PORT}/ibmmq/rest/v2/admin"
    
    try:
        # This is a placeholder - actual MQ REST API implementation
        # would depend on your MQ version and configuration
        qmgr_url = f"{base_url}/qmgr"
        response = requests.get(qmgr_url, verify=False, timeout=5)
        
        if response.status_code == 200:
            data = response.json()
            return {"rest_data": data}
        else:
            return get_mq_info_dspmq()  # Fallback to dspmq
    except:
        return get_mq_info_dspmq()  # Fallback to dspmq

# ---------- MAIN ----------
def main():
    os.makedirs(OUTPUT_DIR, exist_ok=True)
    
    print("Collecting system information...")
    system_info = get_system_info()
    
    print("Reading certificates...")
    certificates = read_all_certificates()
    
    print("Checking ACE status via REST API...")
    ace_info = get_ace_info_rest()
    ace_node_info = get_ace_node_info_rest()
    
    # Combine ACE information
    ace_combined = {
        "node_info": ace_node_info,
        "servers": ace_info
    }
    
    print("Checking MQ status...")
    mq_info = get_mq_info()
    
    snapshot = {
        "timestamp": datetime.now().isoformat(),
        "system": system_info,
        "certificates": certificates,
        "ace": ace_combined,
        "mq": mq_info,
    }
    
    server_ip = snapshot["system"]["ip"]
    outfile = f"{OUTPUT_DIR}/{server_ip}.json"
    
    with open(outfile, "w") as f:
        json.dump(snapshot, f, indent=2)
    
    print(f"\n✓ Generated: {outfile}")
    print(f"✓ System: {system_info['hostname']} ({server_ip})")
    
    # Summary
    cert_count = 0
    for store in certificates.values():
        if isinstance(store, dict) and "error" not in store:
            cert_count += len(store)
    print(f"✓ Certificates found: {cert_count}")
    
    if "error" not in ace_info:
        print(f"✓ ACE integration servers: {len(ace_info)}")
    else:
        print(f"⚠ ACE: {ace_info['error']}")
    
    if "error" not in mq_info:
        print(f"✓ MQ queue managers: {len(mq_info)}")
    else:
        print(f"⚠ MQ: {mq_info['error']}")

if __name__ == "__main__":
    main()
