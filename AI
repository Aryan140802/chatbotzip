#!/usr/bin/env python3

import subprocess
import json
import socket
import platform
import requests
from pathlib import Path
from datetime import datetime
import sys

# ===================== CONFIG =====================

ENVIRONMENT = "PR"          # PR or DR
SERVER_ID = "24"            # 24 / 25 / 40 / 42

# ---- ACE Admin REST ----
ACE_ADMIN_HOST = "localhost"
ACE_ADMIN_PORT = 4414
ACE_USER = "admin"
ACE_PASSWORD = "password"

# ---- Certificate path ----
CERT_DIR = "/sync/certs"    # crt / cer / pem
CERT_EXT = (".crt", ".cer", ".pem")

# ---- Output ----
OUTPUT_DIR = "/sync/outbox"

# =================================================


def run(cmd):
    return subprocess.check_output(cmd, text=True, stderr=subprocess.DEVNULL)


# ---------------- SERVER INFO ----------------

def get_server_info():
    return {
        "hostname": socket.gethostname(),
        "ip": socket.gethostbyname(socket.gethostname()),
        "os": platform.platform()
    }


# ---------------- ACE INFO ----------------

def get_ace_data():
    base = f"https://{ACE_ADMIN_HOST}:{ACE_ADMIN_PORT}/apiv2"
    auth = (ACE_USER, ACE_PASSWORD)
    ace = {"integration_servers": {}}

    try:
        servers = requests.get(
            f"{base}/servers",
            auth=auth,
            verify=False,
            timeout=5
        ).json()["servers"]

        for s in servers:
            name = s["name"]
            apps_resp = requests.get(
                f"{base}/servers/{name}/applications",
                auth=auth,
                verify=False,
                timeout=5
            ).json()

            ace["integration_servers"][name] = [
                {
                    "name": a["name"],
                    "status": a.get("status"),
                    "version": a.get("version", "unknown")
                }
                for a in apps_resp.get("applications", [])
            ]

    except Exception as e:
        ace["error"] = str(e)

    return ace


# ---------------- MQ INFO ----------------

def get_mq_info():
    mq = {"queue_managers": []}
    try:
        out = run(["dspmq"])
        for line in out.splitlines():
            if "QMNAME" in line:
                qm = line.split("(")[1].split(")")[0]
                status = "RUNNING" if "RUNNING" in line else "STOPPED"
                mq["queue_managers"].append({
                    "name": qm,
                    "status": status
                })
    except Exception as e:
        mq["error"] = str(e)

    return mq


# ---------------- CERT INFO ----------------

def parse_cert(path):
    out = run([
        "openssl", "x509", "-in", str(path),
        "-noout", "-subject", "-issuer",
        "-dates", "-fingerprint", "-sha256"
    ])

    data = {}
    for l in out.splitlines():
        if l.startswith("subject="):
            data["subject"] = l.split("=", 1)[1]
        elif l.startswith("issuer="):
            data["issuer"] = l.split("=", 1)[1]
        elif l.startswith("notBefore="):
            data["valid_from"] = l.split("=", 1)[1]
        elif l.startswith("notAfter="):
            data["valid_to"] = l.split("=", 1)[1]
        elif "Fingerprint" in l:
            data["fingerprint"] = l.split("=")[1]

    return data


def get_cert_info():
    certs = []
    for f in Path(CERT_DIR).glob("*"):
        if f.suffix.lower() in CERT_EXT:
            try:
                certs.append({
                    "alias": f.stem,
                    **parse_cert(f)
                })
            except Exception:
                pass
    return certs


# ---------------- MAIN ----------------

def main():
    snapshot = {
        "environment": ENVIRONMENT,
        "server_id": SERVER_ID,
        "generated_at": datetime.utcnow().isoformat() + "Z",
        "server_info": get_server_info(),
        "ace": get_ace_data(),
        "mq": get_mq_info(),
        "certificates": get_cert_info()
    }

    Path(OUTPUT_DIR).mkdir(parents=True, exist_ok=True)

    out_file = Path(OUTPUT_DIR) / f"snapshot_{ENVIRONMENT}_{SERVER_ID}.json"
    with open(out_file, "w") as f:
        json.dump(snapshot, f, indent=2)

    print(f"Snapshot generated: {out_file}")


if __name__ == "__main__":
    main()
