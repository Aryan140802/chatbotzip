#!/usr/bin/env python3

import os
import json
import subprocess
from datetime import datetime

# ==============================
# HARD-CODED (TEST ONLY)
# ==============================
ACE_USER = "v1019468"
ACE_PASS = "Eisking@1234567"

CERT_DIRS = [
    "/opt/IBM/EndPoint_Public",
    "/opt/IBM/EndPoint_Private"
]

OUTPUT_DIR = "/home/scripts/output"
HOSTNAME = os.uname().nodename

# Ensure output dir
os.makedirs(OUTPUT_DIR, exist_ok=True)

# ==============================
# UTILS
# ==============================
def run(cmd):
    return subprocess.check_output(
        cmd,
        stderr=subprocess.DEVNULL,
        text=True
    )

# ==============================
# CERTIFICATE HANDLING
# ==============================
def read_x509(cert):
    try:
        out = run(["openssl", "x509", "-in", cert, "-noout", "-dates", "-fingerprint", "-sha1"])
        data = {}
        for line in out.splitlines():
            if line.startswith("notBefore"):
                data["valid_from"] = line.split("=", 1)[1]
            elif line.startswith("notAfter"):
                data["valid_to"] = line.split("=", 1)[1]
            elif "Fingerprint" in line:
                data["sha1"] = line.split("=", 1)[1]
        return data
    except:
        return {"error": "Unable to read"}

def parse_keytool(out):
    certs = []
    current = {}
    for line in out.splitlines():
        line = line.strip()
        if line.startswith("Alias name:"):
            if current:
                certs.append(current)
            current = {"alias": line.split(":", 1)[1].strip()}
        elif line.startswith("Valid from:"):
            parts = line.replace("Valid from:", "").split("until:")
            current["valid_from"] = parts[0].strip()
            current["valid_to"] = parts[1].strip()
        elif line.startswith("SHA1:"):
            current["sha1"] = line.split(":", 1)[1].strip()
    if current:
        certs.append(current)
    return certs

def read_jks(jks):
    passwords = ["changeit", "password", "ibmwebspheremq"]
    for pwd in passwords:
        try:
            out = run([
                "keytool", "-list", "-v",
                "-keystore", jks,
                "-storepass", pwd
            ])
            return {
                "storepass": pwd,
                "certs": parse_keytool_output(out)
            }
        except:
            continue
    return {"error": "Invalid keystore password"}

def collect_certificates():
    result = {}
    for d in CERT_DIRS:
        if not os.path.isdir(d):
            continue
        for f in os.listdir(d):
            full = os.path.join(d, f)
            if not os.path.isfile(full):
                continue
            if f.endswith((".cer", ".crt", ".pem")):
                result[f] = read_x509(full)
            elif f.endswith(".jks"):
                result[f] = read_jks(full)
    return result

# ==============================
# ACE HANDLING (NO MQ)
# ==============================
def collect_ace():
    ace = {}

    try:
        nodes = run(["mqsilist"]).splitlines()
    except:
        return {"error": "mqsilist failed"}

    for node in nodes:
        node = node.strip()
        if not node or node.startswith("BIP"):
            continue

        ace[node] = {"execution_groups": []}

        try:
            egs = run(["mqsilist", node]).splitlines()
            for eg in egs:
                eg = eg.strip()
                if eg and not eg.startswith("BIP"):
                    ace[node]["execution_groups"].append(eg)
        except:
            ace[node]["execution_groups_error"] = "Unable to list EGs"

    return ace

# ==============================
# MAIN
# ==============================
def main():
    snapshot = {
        "server": HOSTNAME,
        "timestamp": datetime.utcnow().isoformat() + "Z",
        "certificates": collect_certificates(),
        "ace": collect_ace()
    }

    out_file = os.path.join(
        OUTPUT_DIR,
        f"{HOSTNAME}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
    )

    with open(out_file, "w") as f:
        json.dump(snapshot, f, indent=2)

    print(f"Snapshot generated: {out_file}")

if __name__ == "__main__":
    main()
