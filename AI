#!/usr/bin/env python3
import os
import json
import socket
import subprocess
import platform
import requests
from datetime import datetime
from requests.auth import HTTPBasicAuth
import urllib3

# Disable SSL warnings if using self-signed certificates
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# ================== CONFIG ==================
OUTPUT_DIR = "./sync"
ENDPOINT_PUBLIC_PATH = "/opt/IBM/EndPoint_Public"
TRUSTSTORE_PATH = "/opt/IBM/Broker_Properties/JKS/EISBRK10_PROD_N1_TRUSTSTORE.jks"
KEYSTORE_PATH = "/opt/IBM/Broker_Properties/JKS/EISBRK10_PROD_N1_KEYSTORE.jks"
JKS_PASSWORD = "password"


try:
    # Executes Linux command 'hostname -I' and picks the first IP returned
    ACE_ADMIN_HOST = subprocess.check_output(['hostname', '-I']).decode('utf-8').split()[0]
except Exception:
    ACE_ADMIN_HOST = "127.0.0.1"


# ============================================

def run(cmd):
    """Execute command and return output"""
    try:
        return subprocess.check_output(cmd, stderr=subprocess.STDOUT, text=True)
    except subprocess.CalledProcessError as e:
        return None

# ---------- SYSTEM INFO ----------
def get_system_info():
    uptime = run(["uptime"])
    return {
        "hostname": socket.gethostname(),
        "ip": socket.gethostbyname(socket.gethostname()),
        "os": platform.platform(),
        "uptime": uptime.strip() if uptime else "N/A",
    }

# ---------- CERTIFICATE READING ----------
def parse_openssl_cert(file_path):
    """Parse certificate using openssl (for .crt, .cer, .pem files)"""
    cmd = ["openssl", "x509", "-in", file_path, "-noout", "-startdate", "-enddate", "-fingerprint", "-subject"]
    output = run(cmd)

    if not output:
        return {"error": "Unable to read certificate"}

    data = {}
    for line in output.splitlines():
        if line.startswith("notBefore="):
            data["valid_from"] = line.split("=", 1)[1].strip()
        elif line.startswith("notAfter="):
            data["valid_to"] = line.split("=", 1)[1].strip()
        elif line.startswith("SHA1"):
            data["sha1"] = line.split("=", 1)[1].strip()
        elif line.startswith("subject="):
            data["subject"] = line.split("=", 1)[1].strip()

    return data

def parse_keytool_cert(store_path, storepass, alias):
    """Parse specific certificate from JKS using keytool"""
    cmd = ["keytool", "-list", "-v", "-keystore", store_path, "-storepass", storepass, "-alias", alias]
    output = run(cmd)

    if not output:
        return {"error": "Unable to read certificate"}

    data = {"alias": alias}
    for line in output.splitlines():
        if "Valid from:" in line:
            parts = line.split("until:")
            if len(parts) == 2:
                data["valid_from"] = parts[0].split("from:")[1].strip()
                data["valid_to"] = parts[1].strip()
        elif "SHA1:" in line:
            data["sha1"] = line.split("SHA1:")[1].strip()
        elif "Owner:" in line:
            data["owner"] = line.split("Owner:")[1].strip()

    return data

def list_jks_aliases(store_path, storepass):
    """List all aliases in a JKS keystore"""
    cmd = ["keytool", "-list", "-keystore", store_path, "-storepass", storepass]
    output = run(cmd)

    if not output:
        return []

    aliases = []
    for line in output.splitlines():
        if "keyEntry" in line or "trustedCertEntry" in line or "privateKeyEntry" in line:
            alias = line.split(",")[0].strip()
            aliases.append(alias)

    return aliases

def read_jks_store(store_path, store_name, storepass):
    """Read all certificates from a JKS store"""
    if not os.path.exists(store_path):
        return {store_name: {"error": "Store not found"}}

    aliases = list_jks_aliases(store_path, storepass)

    if not aliases:
        return {store_name: {"error": "Unable to read store or no certificates"}}

    certs = {}
    for alias in aliases:
        cert_data = parse_keytool_cert(store_path, storepass, alias)
        certs[alias] = cert_data

    return {store_name: certs}

def read_endpoint_certs():
    """Read all endpoint certificates from the endpoint public directory"""
    if not os.path.isdir(ENDPOINT_PUBLIC_PATH):
        return {"EndPoint_Public": {"error": "Directory not found"}}

    certs = {}
    files = os.listdir(ENDPOINT_PUBLIC_PATH)

    for file_name in files:
        full_path = os.path.join(ENDPOINT_PUBLIC_PATH, file_name)

        # Skip directories
        if not os.path.isfile(full_path):
            continue

        # Only process certificate files
        if file_name.endswith((".crt", ".cer", ".pem", ".cert")):
            cert_data = parse_openssl_cert(full_path)
            certs[file_name] = cert_data

    return {"EndPoint_Public": certs}

def read_all_certificates():
    """Collect all certificates from all sources"""
    all_certs = {}

    # Read Truststore
    truststore_certs = read_jks_store(TRUSTSTORE_PATH, "Truststore", JKS_PASSWORD)
    all_certs.update(truststore_certs)

    # Read Keystore
    keystore_certs = read_jks_store(KEYSTORE_PATH, "Keystore", JKS_PASSWORD)
    all_certs.update(keystore_certs)

    # Read EndPoint Public
    endpoint_certs = read_endpoint_certs()
    all_certs.update(endpoint_certs)

    return all_certs


# ---------- MAIN ----------
def main():
    os.makedirs(OUTPUT_DIR, exist_ok=True)

    print("Collecting system information...")
    system_info = get_system_info()

    print("Reading certificates...")
    certificates = read_all_certificates()



    snapshot = {
        "timestamp": datetime.now().isoformat(),
        "system": system_info,
        "certificates": certificates,
    }
    server_ip = snapshot["system"]["ip"]
    outfile = f"{OUTPUT_DIR}/{server_ip}.json"

    with open(outfile, "w") as f:
        json.dump(snapshot, f, indent=2)

    print(f"\n✓ Generated: {outfile}")
    print(f"✓ System: {system_info['hostname']} ({server_ip})")

    # Summary
    cert_count = 0
    for store in certificates.values():
        if isinstance(store, dict) and "error" not in store:
            cert_count += len(store)
    print(f"✓ Certificates found: {cert_count}")


if __name__ == "__main__":
    main()
