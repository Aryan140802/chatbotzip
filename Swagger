const parseServiceOption = (service) => {
  const [name, type = ""] = service.split('-');
  return {
    name: name.trim(),
    type: type.trim().toUpperCase(),
    fullValue: service
  };
};

const DynamicForm = ({
  fields,
  onSubmit,
  onCancel,
  formType,
  onFieldChange,
  isSubmittingFromParent,
  clearFormSession,
}) => {
  const [fieldDefs, setFieldDefs] = useState(fields);
  const [formData, setFormData] = useState(() =>
    Object.fromEntries(fields.map(f => [f.name, f.value || ""]))
  );
  const [errors, setErrors] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [selectedFilter, setSelectedFilter] = useState(null);

  const handleClearService = () => {
    const updatedFormData = {
      service: "",
      layer: "",
      server: "",
      eg: ""
    };
    setFormData(updatedFormData);
    setErrors({});
    
    if (onFieldChange) {
      onFieldChange(updatedFormData, 'service');
    }
  };

  const handleSelectChange = async (name, value) => {
    let updated = { ...formData };
    
    if (name === 'service') {
      const serviceDetails = parseServiceOption(value);
      if (serviceDetails.type === 'APPLICATION') {
        alert('Warning: Swagger is not available for Application type services');
        return;
      }
      updated[name] = serviceDetails.name;
    } else {
      updated[name] = value;
    }

    updated = applyCascadingLogic(updated, name);
    setFormData(updated);
    
    if (errors[name]) {
      setErrors(prev => ({ ...prev, [name]: null }));
    }

    if (onFieldChange) {
      const filtered = filterNonEmptyFields(updated);
      await onFieldChange(filtered, name);
    }
  };

  const renderField = (field) => {
    const {
      name,
      label,
      type,
      options = [],
      placeholder,
    } = field;
    const value = formData[name] || "";
    const error = errors[name];
    const isService = name === "service";
    const isRequiredField = field.required;

    const formFieldStyle = {
      marginBottom: '15px',
      position: 'relative',
    };

    const labelStyle = {
      display: 'block',
      marginBottom: '5px',
      fontSize: '14px',
      fontWeight: '500',
      color: '#333',
    };

    const selectContainerStyle = {
      position: 'relative',
      display: 'flex',
      alignItems: 'center',
    };

    const selectStyle = {
      width: '100%',
      padding: '8px 12px',
      fontSize: '14px',
      border: error ? '1px solid #dc3545' : '1px solid #ced4da',
      borderRadius: '4px',
      backgroundColor: '#fff',
      appearance: 'none',
      paddingRight: isService ? '40px' : '12px',
    };

    const clearButtonStyle = {
      position: 'absolute',
      right: '5px',
      background: 'none',
      border: 'none',
      cursor: 'pointer',
      padding: '5px',
      color: '#666',
      fontSize: '16px',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      width: '30px',
      height: '30px',
      borderRadius: '50%',
      transition: 'background-color 0.2s',
    };

    const serviceInfoStyle = {
      marginTop: '5px',
      fontSize: '12px',
      display: 'flex',
      justifyContent: 'space-between',
      alignItems: 'center',
      padding: '4px 8px',
      backgroundColor: '#f8f9fa',
      borderRadius: '4px',
    };

    const serviceTypeStyle = (type) => ({
      padding: '2px 8px',
      borderRadius: '3px',
      fontSize: '11px',
      fontWeight: 'bold',
      backgroundColor: type === 'RESTAPI' ? 'rgba(40, 167, 69, 0.1)' : 'rgba(220, 53, 69, 0.1)',
      color: type === 'RESTAPI' ? '#28a745' : '#dc3545',
    });

    const errorStyle = {
      color: '#dc3545',
      fontSize: '12px',
      marginTop: '4px',
    };

    switch (type) {
      case "select":
        return (
          <div style={formFieldStyle} key={name}>
            <label style={labelStyle}>
              {isRequiredField && <span style={{ color: "red" }}>* </span>}
              {label.replace('* ', '')}
            </label>
            <div style={selectContainerStyle}>
              <select
                value={value}
                onChange={e => handleSelectChange(name, e.target.value)}
                style={selectStyle}
                disabled={isSubmitting || isSubmittingFromParent || options.length === 0}
              >
                <option value="">Select {label.replace('* ', '').toLowerCase()}</option>
                {options.map((opt, idx) => {
                  if (isService) {
                    const { name, type, fullValue } = parseServiceOption(opt);
                    return (
                      <option 
                        key={idx} 
                        value={fullValue}
                        style={{
                          display: 'flex',
                          justifyContent: 'space-between',
                          padding: '4px 8px',
                        }}
                      >
                        {`${name} ${type ? `(${type})` : ''}`}
                      </option>
                    );
                  }
                  return (
                    <option key={idx} value={opt.value || opt}>
                      {opt.label || opt}
                    </option>
                  );
                })}
              </select>
              {isService && value && (
                <button
                  type="button"
                  onClick={handleClearService}
                  style={clearButtonStyle}
                >
                  âœ•
                </button>
              )}
            </div>
            {error && <span style={errorStyle}>{error}</span>}
            {isService && value && (
              <div style={serviceInfoStyle}>
                <span>Selected: {value}</span>
                {options.find(opt => opt.includes(value))?.split('-')[1] && (
                  <span style={serviceTypeStyle(
                    options.find(opt => opt.includes(value))?.split('-')[1].trim().toUpperCase()
                  )}>
                    {options.find(opt => opt.includes(value))?.split('-')[1].trim().toUpperCase()}
                  </span>
                )}
              </div>
            )}
          </div>
        );

      case "date":
        return (
          <div style={formFieldStyle} key={name}>
            <label style={labelStyle}>
              {isRequiredField && <span style={{ color: "red" }}>* </span>}
              {label.replace('* ', '')}
            </label>
            <input
              type="date"
              value={value}
              onChange={e => handleInputChange(name, e.target.value)}
              style={{
                ...selectStyle,
                cursor: 'pointer',
              }}
              disabled={isSubmitting || isSubmittingFromParent}
            />
            {error && <span style={errorStyle}>{error}</span>}
          </div>
        );

      default:
        return (
          <div style={formFieldStyle} key={name}>
            <label style={labelStyle}>
              {isRequiredField && <span style={{ color: "red" }}>* </span>}
              {label.replace('* ', '')}
            </label>
            <input
              type="text"
              value={value}
              onChange={e => handleInputChange(name, e.target.value)}
              onBlur={() => handleBlur(name)}
              placeholder={placeholder || ""}
              style={selectStyle}
              disabled={isSubmitting || isSubmittingFromParent}
            />
            {error && <span style={errorStyle}>{error}</span>}
          </div>
        );
    }
  };

  const handleInputChange = (name, value) => {
    let updated = { ...formData, [name]: value };
    updated = applyCascadingLogic(updated, name);
    setFormData(updated);
    if (errors[name]) setErrors(prev => ({ ...prev, [name]: null }));
  };

  const handleBlur = async (name) => {
    if (onFieldChange) {
      const filtered = filterNonEmptyFields(formData);
      await onFieldChange(filtered, name);
    }
  };

  const handleSubmit = async e => {
    e.preventDefault();

    const missing = fieldDefs.filter(f => f.required && !formData[f.name]);

    if (missing.length > 0) {
      setErrors(prev => ({
        ...prev,
        ...Object.fromEntries(missing.map(f => [f.name, "This field is required."]))
      }));
      return;
    }

    setIsSubmitting(true);
    await onSubmit(formData, fieldDefs);
    setIsSubmitting(false);
  };

  return (
    <div style={{
      padding: '20px',
      backgroundColor: '#fff',
      borderRadius: '8px',
      boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
      margin: '10px 0',
    }}>
      <form onSubmit={handleSubmit}>
        {fieldDefs.map(renderField)}
        <div style={{
          display: 'flex',
          justifyContent: 'flex-end',
          gap: '10px',
          marginTop: '20px',
        }}>
          <button
            type="button"
            onClick={onCancel}
            style={{
              padding: '8px 16px',
              border: '1px solid #ced4da',
              borderRadius: '4px',
              backgroundColor: '#fff',
              color: '#666',
              cursor: 'pointer',
              fontSize: '14px',
            }}
            disabled={isSubmitting}
          >
            Cancel
          </button>
          <button
            type="submit"
            style={{
              padding: '8px 16px',
              border: 'none',
              borderRadius: '4px',
              backgroundColor: '#007bff',
              color: '#fff',
              cursor: 'pointer',
              fontSize: '14px',
              opacity: (isSubmitting || isSubmittingFromParent) ? 0.7 : 1,
            }}
            disabled={isSubmitting || isSubmittingFromParent}
          >
            {isSubmitting || isSubmittingFromParent ? "Processing..." : "Submit"}
          </button>
        </div>
      </form>
    </div>
  );
};

export default DynamicForm;
